package com.study.fooddelivery.implementation;

import com.study.fooddelivery.constants.Constants;
import com.study.fooddelivery.entity.Billing;
import com.study.fooddelivery.entity.Order;
import com.study.fooddelivery.entity.OrderItem;
import com.study.fooddelivery.service.OrderService;

public class OrderServiceImpl implements OrderService {

    @Override
    public Order order(Order order) throws Exception {

        // Transaction Id is coming from UI and generated by braintree service. It is used to check the charging status.
        // TODO: Call braintree service to check whether Transaction Id is valid and verify the transaction amount
        // If not, cancel the order

        // calculate total price and verify with the price in the order
        float price = computeTotalPrice(order);
        if(price != order.getPrice()) {
            // something wrong with the price
            // TODO: call billing service to cancel the charging
            order.setOrderStatus(Constants.OrderStatus.CANCELED.getCode());
            //TODO: persist in DB
            throw new Exception("Price is not matching");
        }

        order.setOrderStatus(Constants.OrderStatus.CHARGEISSUED.getCode());

        // After order is completed, billing service issue money to restaurant through braintree service
        Billing billing = new Billing();
        billing.setOrderId(order.getId());
        billing.setPrice(order.getPrice());
        billing.setTransactionId(order.getTransactionId());
        billing.setBillingStatus(Constants.BillingStatus.INITIALIZED.getCode());

        //TODO: send order to kafka queue for notification to restaurant

        //TODO: persist in DB

        return order;
    }

    @Override
    public float computeTotalPrice(Order order) {
        float price = 0;
        for(OrderItem item: order.getOrderItems()) {
            price += item.getPrice() * item.getQuantity();
        }
        return price;
    }
}
